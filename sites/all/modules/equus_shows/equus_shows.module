<?php 
require("equus_shows_show.inc");
/**
 * Implements hook_node_info()
 */
function equus_shows_node_info() {
	return array(
		'show' => array(
			'name' => t('Show'),
			'base' => 'show',
			'description' => t('A show'),
			'has_title' => TRUE,
			'title_label' => t('Name')
			
		)
	);
}

function equus_shows_node_type_insert($node_type) {
	if ($node_type->type == 'show') {

	}
}

function show_form($node, $form_state) {
	return node_content_form($node, $form_state);
}

function equus_shows_menu() {
	$items = array();
 
	$items['examples/enter-show'] = array( //this creates a URL that will call this form at "examples/form-example"
		'title' => 'Enter Show', //page title
		'description' => 'Enter a show.',
		'page callback' => 'drupal_get_form', //this is the function that will be called when the page is accessed. 
		// for a form, use drupal_get_form
		'page arguments' => array('equus_shows_entry_form'), //put the name of the form here
		'access callback' => TRUE
	);

	return $items;
}

/**
 * Implements hook_block_info().
 *
 * This function tells drupal about our block.
 *
 * For more information on this function, see:
 * http://api.drupal.org/api/drupal/modules block block.api.php/function/hook_block_info/7
 */
function equus_shows_block_info() {
	// Create an array that will hold our blocks
	$blocks = array();

	// Create a key in our $blocks array that
	// defines our block. Note that the key in
	// this array can be anything. For this
	// tutorial, we use 'tellafriend_form'.
	$blocks['equus_shows_entry_form'] = array(
		// 'info' is what you will see when viewing the blocks admin page.
		// Note that we use the t() (translate) function which lets drupal
		// translate any text passed in if needed.
		'info' => t('Enter Show'),
		// 'cache' how this block will be cached
		'cache' => DRUPAL_CACHE_GLOBAL,
	);
	$blocks['equus_shows_compute_form'] = array(
		// 'info' is what you will see when viewing the blocks admin page.
		// Note that we use the t() (translate) function which lets drupal
		// translate any text passed in if needed.
		'info' => t('Run Show'),
		// 'cache' how this block will be cached
		'cache' => DRUPAL_CACHE_GLOBAL,
	);

	// Note, if you wanted to define multiple blocks, you
	// could simply define more blocks just like above.

	// Finally, we return the $blocks array.
	return $blocks;
}

/**
 * Implements hook_block_view().
 *
 * This function tells drupal how to define our block when viewed.
 *
 * For more information on this function, see:
 * http://api.drupal.org/api/drupal/modules block block.api.php/function/hook_block_view/7
 */
function equus_shows_block_view($delta = '') {
	// Create an array that will be returned as our block
	$block = array();
	 
	// Since hook_block_view is called for every block,
	// Drupal passes in $delta (the key of the blocks defined
	// in hook_block_info. In our case, we're checking for
	// $delta to be 'tellafriend_form'.
	switch($delta) {
		case 'equus_shows_entry_form':
			// Since this $delta matches our case, we'll define
			// the subject and contents.
			 
			// 'subject' can be blank ('') or anything you wish to define.
			$block['subject'] = t('Enter this show');
			 
			// 'content' are just that, the contents of the block.
			// In our case, we will be showing a form.
			// We use drupal_get_form() to return a drupal-built form.
			// Note that the parameter passed to drupal_get_form is the name
			// of the function we will build below to define our form.
			// This can be any function name we define below.
			$block['content'] = drupal_get_form('equus_shows_entry_form');
			break;
		case 'equus_shows_compute_form':
			$block['subject'] = t('Run this show');
			$block['content'] = drupal_get_form('equus_shows_compute_form');
			break;
	}
	 
	// Finally, we return the $block array.
	return $block;
}

function equus_shows_entry_form($form, &$form_state) {
	// find logged in user id
	// EFQ for horses with that owner

	$query = new EntityFieldQuery();
	$query
		->entityCondition('entity_type', 'node')
		->entityCondition('bundle', 'horse')
		->propertyCondition('status', 1)
		->fieldCondition('field_horse_activation_status', 'value', 'Active', '=')
		->propertyCondition('uid', $GLOBALS['user']->uid)
		->propertyOrderBy('created', 'DESC');
	$result = $query->execute();
	$nids = array_keys($result['node']);
	$nodes = node_load_multiple($nids);

	$horse_list = array();

	foreach ($nodes as $node) {
		$horse_list[$node->nid] = $node->title;
	}

	$form['horseid'] = array(
		'#type' => 'select', //you can find a list of available types in the form api
		'#title' => 'Select a horse',
		'#multiple' => FALSE,
		'#options' => $horse_list,
		'#required' => TRUE, //make this field required
	);

	$form['submit_button'] = array(
		'#type' => 'submit',
		'#value' => t('Submit entry'),
	);

	return $form;
}

function equus_shows_entry_form_validate($form, &$form_state) {
	$node = node_load($form_state['values']['horseid']);
	if ($node == FALSE) {
		form_set_error('horseid', t('Horse does not exist.'));
	} else {
		if ($node->type != 'horse') {
			form_set_error('horseid', t('Entrant must be a horse.'));
		}
	}

	$node = menu_get_object();
	if ($node) {
		// Use the node object.
		if ($node->type != 'show') {
			form_set_error('submit_button', t('You may only run shows.'));
		} else {
			$form_state['showid'] = $node->nid;
		}
	} else {
		form_set_error('showid', t('Show does not exist.'));
	}
}

function equus_shows_entry_form_submit($form, &$form_state) {
	equus_shows_enter_show($form_state['showid'], $form_state['values']['horseid'], NULL);
}

function equus_shows_compute_form($form, &$form_state) {
	$form['submit_button'] = array(
		'#type' => 'submit',
		'#value' => t('Run the show'),
	);

	return $form;
}

function equus_shows_compute_form_validate($form, &$form_state) {
	if ($node = menu_get_object()) {
		// Use the node object.
		if ($node->type != 'show') {
			form_set_error('submit_button', t('You may only run shows.'));
		} else {
			$form_state['showid'] = $node->nid;
		}
	} else {
		form_set_error('showid', t('Show does not exist.'));
	}
}

function equus_shows_compute_form_submit($form, &$form_state) {
	// dpm($form);
	equus_shows_run_show($form_state['showid']);
}

function equus_shows_enter_show($showid,$horseid,$data) {
	$entry_fee = 8;

	$show = node_load($showid);
	if (!$show) {
		drupal_set_message(t('Show does not exist.'), 'error');
		return false;
	}

	$horse = node_load($horseid);
	if (!$horse) {
		drupal_set_message(t('Horse does not exist.'), 'error');
		return false;
	}

	$residence_id = $horse->field_horse_residence[LANGUAGE_NONE][0]['target_id'];

	$residence = node_load($residence_id);
	if (!$residence) {
		drupal_set_message(t('Residence does not exist.'), 'error');
		return false;
	}

	$source_id = $residence->field_property_ownership[LANGUAGE_NONE][0]['target_id'];

	$source = node_load($source_id);
	if (!$source_id) {
		drupal_set_message(t('Source organization does not exist.'), 'error');
		return false;
	}

	$ledger = equus_banking_retrieve_ledger();

	$org_balance = equus_banking_balance($ledger, $source_id);

	if ($org_balance < $entry_fee) {
		drupal_set_message(t('You do not have enough money for this entry.'), 'error');
		return false;
	}

	$endpoints = array();
	$endpoints[] = array('entity_type' => 'node', 'entity_id' => $horseid);
	$endpoints[] = array('entity_type' => 'node', 'entity_id' => $showid);

	$new_relation = relation_create('is_entered_in', $endpoints);

	$rid = relation_save($new_relation);
	if (!$rid) {
		drupal_set_message(t('Relation create failed in equus_shows_enter_show.'), 'error');
		return false;
	}

	$show_name = $show->title;

	$horse_name = $horse->title;

	$destination = $show->field_hosting_organization[LANGUAGE_NONE][0]['target_id'];

	//dpm($source);

	equus_banking_create_transaction("Entry fee for $horse_name in $show_name.", $source_id, $destination, $entry_fee);
}

function _equus_shows_sum($carry, $item) {
    $carry += $item;
    return $carry;
}

function equus_shows_run_show($show_id) {
	$show = node_load($show_id);

	dpm($show);

	// build array of stuff
	$raw_data = new stdClass();
	$raw_data->horses = [];
	$raw_data->judges = [];
	$raw_data->discipline = new stdClass();

	// fill in judges
	$newjudge = new stdClass();
	$newjudge->type = "Judge";
	$newjudge->id = 1;
	$newjudge->name = "Impartial Judge";
	$newjudge->stat_preferences = new stdClass();
	$raw_data->judges[] = $newjudge;

	// fill in discipline
	$raw_data->discipline->type = $show->field_discipline['und'][0]['taxonomy_term']->name;
	$raw_data->discipline->id = $show->field_discipline['und'][0]['tid'];

	// get the id of the field collection item
	$disc_stat_weights = $show->field_discipline['und'][0]['taxonomy_term']->field_disc_stat_weight['und'];
	// dpm($disc_stat_weights[0]['value']);

	// make a new anonymous object
	$raw_data->discipline->stats = new stdClass();

	// get the stat and stat weight values for the discipline
	for ($i = 0; $i < count($disc_stat_weights); $i++) {
		// load the field collection item from the id
		$stats = field_collection_item_load($disc_stat_weights[$i]['value']);

		// dpm($field_collection_item);

		$stat = $stats->field_stat['und'][0]['value'];

		// dpm($stat);
		
		$stat_weight = $stats->field_stat_weight['und'][0]['value'];

		$raw_data->discipline->stats->$stat = $stat_weight;

		// dpm($stat_weight);
		
	}

	// fill in the horses
	// relation_query($entity_type, entity_id, r_index)
	// $entity_type = The entity type of one of the endpoints
	// $entity_id = The entity id of one of the endpoints. Can also be an array of entity IDs.
	// $r_index = The index of the search entity in the relation to be found (0 = source, 1 = target)
	$query = relation_query('node', $show_id, 1);
	$results = $query->entityCondition('bundle', 'is_entered_in')->execute();

	$rids = array_map(function($o) { return $o->rid; }, $results);

	$places = range(1,count($rids));
	shuffle($places);

	$relations = relation_load_multiple($rids);

	$nids = array_map(function($o) {return $o->endpoints[LANGUAGE_NONE][0]['entity_id'];}, $relations);
	$horses = node_load_multiple($nids);

	dpm($horses);

	// fill in horses
	

	// get horse info
	foreach ($horses as $horse) {
		$newhorse = new stdClass();
		$newhorse->type = "Horse";
		$newhorse->id = $horse->nid;
		$newhorse->name = $horse->title;
		$newhorse->stats = new stdClass();

		// get horse stats
		$stats = $horse->field_horse_stats['und'];
		dpm($stats);
		foreach ($stats as $stat) {
			$field_collection_item = field_collection_item_load($stat['value']);
			
			dpm($field_collection_item);

			$stat_value = $field_collection_item->field_stat['und'][0]['value'];
			
			$stat_weight = $field_collection_item->field_horse_stat_value['und'][0]['value'];

			$newhorse->stats->$stat_value = $stat_weight;
		}
		$raw_data->horses[] = $newhorse;
		
	}

	dpm(json_encode($raw_data,JSON_PRETTY_PRINT));

	// instantiate a show with array from above
	$new_show = new equus_shows_show($raw_data);

    // actually run the show
    $output = $new_show->run_the_show();

    // stuff the results into drupal and/or wherever
    dpm($output);
    dpm(json_encode($output,JSON_PRETTY_PRINT));

    // construct a map of nids to indexes in $output so we can look up
    // values in $output later
    $nid_to_output = [];
    $i = 0;
	foreach ($output as $value) {
		$nid_to_output[$value->id] = $i++;
	}

	foreach ($relations as $relation) {
		$nid = $relation->endpoints[LANGUAGE_NONE][0]['entity_id'];

		$relation->equus_shows_placement[LANGUAGE_NONE][0]['value'] = $output[$nid_to_output[$nid]]->placement;
		relation_save($relation);
	}
}